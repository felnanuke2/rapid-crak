// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `adaptive_chunk_size`, `as_slice`, `build_charset`, `dictionary_attack`, `ensure_valid_zip`, `find_first_encrypted_entry`, `generate_mutations`, `get_pause_flag`, `increment_password`, `index_to_bytes`, `is_empty`, `new`, `report_error`, `report_progress`, `spawn_progress_thread`, `try_unlock_fast`, `try_unlock_ultra_safe`, `try_unlock`, `wait_if_paused`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `CompactCharset`, `CrackResult`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// Sets the pause state globally
Future<void> setPause({required bool paused}) =>
    RustLib.instance.api.crateApiPasswordCrackerSetPause(paused: paused);

/// Gets the current pause state
Future<bool> isPaused() =>
    RustLib.instance.api.crateApiPasswordCrackerIsPaused();

/// Quebra a senha de um arquivo ZIP usando força bruta paralela otimizada v2
/// Fase 1: Dictionary attack (senhas comuns + mutações)
/// Fase 2: Brute force incremental com chunks adaptativos
Stream<CrackProgress> crackZipPassword({
  required List<int> fileBytes,
  required CrackConfig config,
}) => RustLib.instance.api.crateApiPasswordCrackerCrackZipPassword(
  fileBytes: fileBytes,
  config: config,
);

/// Estima o número total de combinações
Future<BigInt> estimateCombinations({required CrackConfig config}) => RustLib
    .instance
    .api
    .crateApiPasswordCrackerEstimateCombinations(config: config);

/// Debug function to test a specific password and see what happens
String debugPasswordTest({
  required List<int> fileBytes,
  required String password,
}) => RustLib.instance.api.crateApiPasswordCrackerDebugPasswordTest(
  fileBytes: fileBytes,
  password: password,
);

/// Versão simplificada para testes (síncrona)
bool testZipPassword({
  required List<int> fileBytes,
  required String password,
}) => RustLib.instance.api.crateApiPasswordCrackerTestZipPassword(
  fileBytes: fileBytes,
  password: password,
);

/// Test a specific password and get detailed results
String testSpecificPassword({
  required List<int> fileBytes,
  required String password,
}) => RustLib.instance.api.crateApiPasswordCrackerTestSpecificPassword(
  fileBytes: fileBytes,
  password: password,
);

/// Configuração para a quebra de senha
class CrackConfig {
  final BigInt minLength;
  final BigInt maxLength;
  final bool useLowercase;
  final bool useUppercase;
  final bool useNumbers;
  final bool useSymbols;
  final bool useDictionary;
  final List<String> customWords;

  const CrackConfig({
    required this.minLength,
    required this.maxLength,
    required this.useLowercase,
    required this.useUppercase,
    required this.useNumbers,
    required this.useSymbols,
    required this.useDictionary,
    required this.customWords,
  });

  static Future<CrackConfig> default_() =>
      RustLib.instance.api.crateApiPasswordCrackerCrackConfigDefault();

  @override
  int get hashCode =>
      minLength.hashCode ^
      maxLength.hashCode ^
      useLowercase.hashCode ^
      useUppercase.hashCode ^
      useNumbers.hashCode ^
      useSymbols.hashCode ^
      useDictionary.hashCode ^
      customWords.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CrackConfig &&
          runtimeType == other.runtimeType &&
          minLength == other.minLength &&
          maxLength == other.maxLength &&
          useLowercase == other.useLowercase &&
          useUppercase == other.useUppercase &&
          useNumbers == other.useNumbers &&
          useSymbols == other.useSymbols &&
          useDictionary == other.useDictionary &&
          customWords == other.customWords;
}

/// Representa o progresso da quebra de senha
class CrackProgress {
  final BigInt attempts;
  final String currentPassword;
  final BigInt elapsedSeconds;
  final double passwordsPerSecond;
  final String phase;

  const CrackProgress({
    required this.attempts,
    required this.currentPassword,
    required this.elapsedSeconds,
    required this.passwordsPerSecond,
    required this.phase,
  });

  @override
  int get hashCode =>
      attempts.hashCode ^
      currentPassword.hashCode ^
      elapsedSeconds.hashCode ^
      passwordsPerSecond.hashCode ^
      phase.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CrackProgress &&
          runtimeType == other.runtimeType &&
          attempts == other.attempts &&
          currentPassword == other.currentPassword &&
          elapsedSeconds == other.elapsedSeconds &&
          passwordsPerSecond == other.passwordsPerSecond &&
          phase == other.phase;
}
